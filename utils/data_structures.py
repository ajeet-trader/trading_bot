from dataclasses import dataclass, field
from datetime import datetime
from typing import Literal, Optional
import sys
from pympler import asizeof


# Using slots=True significantly reduces the memory footprint of each instance.
# Using frozen=True makes the objects immutable, which is good practice for
# data records like signals and trades to prevent accidental modification.

@dataclass(slots=True, frozen=True)
class Signal:
    """
    Represents a trading signal generated by a strategy. Immutable.
    """
    timestamp: datetime
    symbol: str
    strategy: str
    signal_type: Literal['BUY', 'SELL', 'HOLD']
    price: float  # The price at which the signal was generated
    confidence: Optional[float] = None # Optional confidence score (0.0 to 1.0)

@dataclass(slots=True, frozen=True)
class Trade:
    """
    Represents a single, completed trade execution. Immutable.
    """
    timestamp: datetime
    symbol: str
    action: Literal['BUY', 'SELL']
    quantity: float
    price: float
    commission: float = 0.0
    trade_id: str = field(default_factory=lambda: f"trade_{int(datetime.now().timestamp() * 1e6)}")

# Positions are mutable as their state changes with the market.
@dataclass(slots=True, frozen=False)
class Position:
    """
    Represents an open position for a specific symbol. Mutable.
    """
    symbol: str
    entry_price: float
    quantity: float
    side: Literal['LONG', 'SHORT']
    entry_timestamp: datetime
    current_price: float = 0.0
    
    def update_price(self, new_price: float):
        """Updates the current market price of the position."""
        self.current_price = new_price

    @property
    def unrealized_pnl(self) -> float:
        """Calculates the unrealized profit or loss."""
        if self.side == 'LONG':
            return (self.current_price - self.entry_price) * self.quantity
        else: # SHORT
            return (self.entry_price - self.current_price) * self.quantity

    @property
    def market_value(self) -> float:
        """Calculates the current market value of the position."""
        return self.current_price * self.quantity

# Example usage and memory test
if __name__ == "__main__":
    # --- Demonstration ---
    now = datetime.now()
    
    # Create a signal
    my_signal = Signal(timestamp=now, symbol='BTC/USDT', strategy='ema_crossover', signal_type='BUY', price=65000.0, confidence=0.85)
    print(f"Created Signal: {my_signal}")
    
    # This line should fail
    #my_signal.price = 66000.0
    
    # Create a trade
    my_trade = Trade(timestamp=now, symbol='BTC/USDT', action='BUY', quantity=0.1, price=65001.50, commission=2.50)
    print(f"Created Trade: {my_trade}")
    
    # Create and update a position
    my_position = Position(symbol='BTC/USDT', entry_price=65001.50, quantity=0.1, side='LONG', entry_timestamp=now)
    my_position.update_price(65500.0)
    print(f"Created Position: {my_position}")
    print(f"Unrealized P&L: ${my_position.unrealized_pnl:.2f}")
    
    # --- Memory Efficiency Test ---
    print("\n--- Memory Test ---")
    
    @dataclass
    class NoSlots: # A regular dataclass for comparison
        a: int
        b: str
        c: float

    @dataclass(slots=True)
    class WithSlots: # Our memory-efficient dataclass
        a: int
        b: str
        c: float

    num_instances = 1_000_000
    
    no_slots_list = [NoSlots(i, 'test', i * 1.0) for i in range(num_instances)]
    with_slots_list = [WithSlots(i, 'test', i * 1.0) for i in range(num_instances)]
    
    # Note: getsizeof measures the size of the list object itself, not the elements.
    # We sum the size of each element for a more accurate comparison.
    size_no_slots = sum(sys.getsizeof(o) for o in no_slots_list)
    size_with_slots = sum(sys.getsizeof(o) for o in with_slots_list)
    
    print(f"Size of {num_instances:,} regular dataclass instances: {size_no_slots / 1e6:.2f} MB")
    print(f"Size of {num_instances:,} slotted dataclass instances: {size_with_slots / 1e6:.2f} MB")
    
    reduction = (1 - size_with_slots / size_no_slots) * 100
    print(f"Memory reduction with __slots__: {reduction:.2f}%")